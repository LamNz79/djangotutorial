# DL-01 — Question Detail BFF Aggregation

## Background
The frontend requires a single, stable BFF endpoint to fetch question details,
including choices and the current user’s vote state.
Existing BFF routes were poll-centric and leaked Django app naming,
resulting in inconsistent contracts and unnecessary frontend complexity.

---

## Problem
- BFF responses were flat and inconsistent across list and detail endpoints
- Domain language used `polls` instead of the real domain entity (`Question`)
- User vote state required multiple calls or inference
- No clear separation between list (overview) and detail (aggregation)

---

## Questions and Answers

**Q1: What is the correct domain root for BFF read APIs?**  
**A:** `Question`. `polls` is a Django app namespace, not a domain entity.

**Q2: Should the BFF expose Django models directly?**  
**A:** No. BFF must reshape responses into stable, frontend-oriented contracts.

**Q3: Should unauthenticated users be supported?**  
**A:** Yes. `userVote` must be nullable.

**Q4: Where should user vote ownership logic live?**  
**A:** In Django. The BFF must never infer vote state.

**Q5: Should responses be wrapped in an envelope?**  
**A:** Yes. All domain payloads are nested under `data` to allow future extension.

---

## Design

### Canonical Endpoints (BFF)
GET /questions
GET /questions/:id

### Detail Response Contract
```ts
{
  data: {
    question: {
      id: number
      text: string
      publishedAt: string
    }
    choices: {
      id: number
      text: string
      voteCount: number
    }[]
    userVote: {
      choiceId: number
    } | null
  }
}
```

```ts
{
  data: {
    questions: {
      id: number
      text: string
      publishedAt: string
      totalVotes: number
    }[]
  }
}
```

## Implementation Plan
### Phase 1 — Detail contract alignment

- Introduce { data } envelope

- Rename fields to domain language

- Remove leaked fields (totalVotes from detail)

### Phase 2 — User vote aggregation

- Fetch per-user vote state from Django

- Interpret 404 as “not voted”

- Keep auth optional

### Phase 3 — List endpoint alignment

- Introduce list envelope

- Keep list lightweight

- Preserve totalVotes for ranking

### Phase 4 — Naming & route cleanup

- Rename BFF files and routes from polls → questions

- Preserve backward compatibility via aliases

### Phase 5 — Verification

- Manually verify contracts and behavior

- Defer automated tests due to missing BFF test infrastructure

## Examples
```JSON
{
  "data": {
    "question": { "id": 1, "text": "Best language?", "publishedAt": "2026-01-01" },
    "choices": [{ "id": 1, "text": "Python", "voteCount": 10 }],
    "userVote": null
  }
}

```
## Trade-offs
### Pros

- Consistent, frontend-friendly contracts

- Clear domain language

- Thin BFF with no business logic duplication

### Cons

- Slightly more BFF aggregation logic

- Requires Django support for user vote lookup

## Implementation Results
### Phase 1

- Detail endpoint reshaped to { data } envelope

- Field names aligned with domain language

### Phase 2

- userVote aggregated from Django

- 404 from Django interpreted as “not voted”

### Phase 3

- List endpoint aligned with detail conventions

- Introduced questions[] list contract

### Phase 4

- BFF routes and files renamed to questions

- Legacy /polls routes preserved as aliases

### Phase 5 — Verification

- Manual verification performed for all BFF endpoints

- Verified auth/unauth and voted/not-voted behavior

- Automated tests deferred due to missing test tooling
